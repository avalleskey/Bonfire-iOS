//
//  Session.m
//  Bonfire
//
//  Created by Austin Valleskey on 6/16/18.
//  Copyright © 2018 Ingenious, Inc. All rights reserved.
//

#import "Session.h"

#import "Launcher.h"
#import "AppDelegate.h"
#import <Lockbox/Lockbox.h>
#import "NSDictionary+Clean.h"
#import "HAWebService.h"
#import "Camp.h"
#import "UIColor+Palette.h"
#import "NSDictionary+Clean.h"
#import "NSArray+Clean.h"
#import <PINCache/PINCache.h>
#import "InsightsLogger.h"

@interface Session ()

@property (nonatomic, strong) dispatch_group_t refreshTokenDispatchGroup;

@end

@implementation Session

static Session *session;

+ (Session *)sharedInstance {
    if (!session) {
        session = [[Session alloc] init];
        
        if ([[NSUserDefaults standardUserDefaults] objectForKey:@"device_token"]) {
            // "user_device_token"  = the device token that is currently associated with a user
            // "device_token"       = the latest device token received/generated by the device
            session.deviceToken = [[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"];
        }
        
        if ([[NSUserDefaults standardUserDefaults] objectForKey:@"user"]) {
            session.currentUser = [[User alloc] initWithData:[[NSUserDefaults standardUserDefaults] objectForKey:@"user"] error:nil];
            NSLog(@"🙎‍♂️ User: @%@", session.currentUser.attributes.details.identifier);
        }
        
        if ([session getAccessTokenWithVerification:true] != nil && session.currentUser.identifier != nil) {
            // update user object
            [BFAPI getUser:^(BOOL success) {
                
            }];
            [session syncDeviceToken];
        }
        
        [session initDefaults];
        [session resetTemporaryDefaults];
    }
    return session;
}

- (void)initDefaults {
    if([[NSUserDefaults standardUserDefaults] dictionaryForKey:@"app_defaults"] == nil) {
        NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@"LocalDefaults" ofType:@"json"];
        NSData *data = [NSData dataWithContentsOfFile:bundlePath];
        NSDictionary *json = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil];
        
        [session updateDefaultsJSON:json];
    }

    NSError* error;
    NSDictionary* dictionaryJSON = [[NSUserDefaults standardUserDefaults] dictionaryForKey:@"app_defaults"];
    
    session.defaults = [[Defaults alloc] initWithDictionary:dictionaryJSON error:&error];
    if (error) {
        NSLog(@"⚠️ session defaults error: %@", error);
    }
    
    // only fetch new defaults if logged in
    if ([session getAccessTokenWithVerification:true] != nil && session.currentUser.identifier != nil) {
        // get new defaults!!
        NSLog(@"get new defaullltss");
        NSString *url = @"clients/defaults.json";
        [[HAWebService authenticatedManager] GET:url parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
            NSError *error;
            NSLog(@"response object: %@", responseObject);
            
            Defaults *newDefaults = [[Defaults alloc] initWithDictionary:responseObject error:&error];
            
            NSLog(@"error: %@", error);
            
            if (!error) {
                NSLog(@"set new defaults because there weren't any errors");
                session.defaults = newDefaults;
                
                // save to local file
                [session updateDefaultsJSON:responseObject];
            }
            else {
                NSLog(@"⚠️ error with new json: %@", error);
            }
        } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
            NSLog(@"😞 darn. error getting the new defaults");
            NSString *ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
            NSLog(@"errorResponse: %@", ErrorResponse);
            NSLog(@"---------");
        }];
    }
    else {
        NSLog(@"don't init defaults");
    }
}
- (void)updateDefaultsJSON:(NSDictionary *)json {
    [[NSUserDefaults standardUserDefaults] setObject:[json clean] forKey:@"app_defaults"];
}

- (void)syncDeviceToken {
    // "user_device_token"  = the device token that is currently associated with a user
    // "device_token"       = the latest device token received/generated by the device
    if (session.currentUser && [[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"] && ![[[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"] isEqualToString:[[NSUserDefaults standardUserDefaults] stringForKey:@"user_device_token"]]) {
        // has device token and it isn't equal the user_device_token
        NSLog(@"🚨 user has a new device token -> we need to register it");
                
        NSString *url = @"users/me/notifications/tokens";
        
        NSLog(@"parameters: %@", @{@"vendor": @"APNS", @"token": [[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"]});
        [[HAWebService authenticatedManager] POST:url parameters:@{@"vendor": @"APNS", @"token": [[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"]} progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
            NSLog(@"🤪 successfully updated the device token for @%@", session.currentUser.attributes.details.identifier);
            [[NSUserDefaults standardUserDefaults] setObject:[[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"] forKey:@"user_device_token"];
            
            session.deviceToken = [[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"];
        } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
            NSLog(@"😞 darn. error updating the device token");
            // NSString *ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
        }];
    }
    else {
        NSLog(@"sync device token didn't qualify");
    }
}

// User
- (void)updateUser:(User *)newUser {
    NSLog(@"updateUser: %@", newUser);
    [[NSUserDefaults standardUserDefaults] setObject:[newUser toJSONData] forKey:@"user"];
    
    session.currentUser = newUser;
    
    NSLog(@"session.currentUser: %@", session.currentUser);
    [[NSNotificationCenter defaultCenter] postNotificationName:@"UserUpdated" object:newUser];
}

- (void)addToRecents:(id)object {
    if ([object isKindOfClass:[Camp class]] ||
        [object isKindOfClass:[User class]]) {
        NSMutableArray *searchRecents = [[NSMutableArray alloc] initWithArray:[[NSUserDefaults standardUserDefaults] arrayForKey:@"recents_search"]];
        
        NSDictionary *objJSON = [object toDictionary];
        
        if ([object isKindOfClass:[Camp class]]) {
            [self incrementOpensForCamp:(Camp *)object];
        }
        
        // add object or push to front if in recents
        BOOL existingMatch = false;
        for (NSInteger i = 0; i < [searchRecents count]; i++) {
            NSDictionary *result = searchRecents[i];
            if (objJSON[@"type"] && objJSON[@"id"] &&
                result[@"type"] && result[@"id"]) {
                if ([objJSON[@"type"] isEqualToString:result[@"type"]] && [[self convertToString:objJSON[@"id"]] isEqualToString:[self convertToString:result[@"id"]]]) {
                    existingMatch = true;
                    
                    [searchRecents removeObjectAtIndex:i];
                    [searchRecents insertObject:objJSON atIndex:0];
                    break;
                }
            }
        }
        if (!existingMatch) {
            // remove context first
            if ([object isKindOfClass:[Camp class]]) {
                Camp *camp = (Camp *)object;
                
                [searchRecents insertObject:[camp toDictionary] atIndex:0];
            }
            else if ([object isKindOfClass:[User class]]) {
                User *user = (User *)object;
                //user.attributes.context = nil;
                
                [searchRecents insertObject:[user toDictionary] atIndex:0];
            }
            
            NSMutableArray *removeObjects = [[NSMutableArray alloc] init];
            NSInteger numOfCamps = 0;
            NSInteger numOfUsers = 0;
            for (NSDictionary *object in searchRecents) {
                if ([object isKindOfClass:[NSDictionary class]] && [object[@"type"] isKindOfClass:[NSString class]]) {
                    if ([object[@"type"] isEqualToString:@"camp"]) {
                        numOfCamps = numOfCamps + 1;
                        if (numOfCamps > 16) {
                            [removeObjects addObject:object];
                        }
                    }
                    if ([object[@"type"] isEqualToString:@"user"]) {
                        numOfUsers = numOfUsers + 1;
                        if (numOfUsers > 16) {
                            [removeObjects addObject:object];
                        }
                    }
                }
            }
            [searchRecents removeObjectsInArray:removeObjects];
        }
        
        // update NSUserDefaults
        [[NSUserDefaults standardUserDefaults] setObject:[searchRecents clean] forKey:@"recents_search"];
        [[NSNotificationCenter defaultCenter] postNotificationName:@"RecentsUpdated" object:nil];
    }
}
- (void)incrementOpensForCamp:(Camp *)camp {
    NSMutableDictionary *opens = [[NSMutableDictionary alloc] initWithDictionary:[[NSUserDefaults standardUserDefaults] dictionaryForKey:@"camp_opens"]];
    
    // set
    NSInteger opensForCamp = [opens objectForKey:camp.identifier] ? [opens[camp.identifier] integerValue] : 0;
    opensForCamp = opensForCamp + 1;
    [opens setObject:[NSNumber numberWithInteger:opensForCamp] forKey:camp.identifier];
    
    // save
    [[NSUserDefaults standardUserDefaults] setObject:opens forKey:@"camp_opens"];
}
- (NSString *)convertToString:(id)object {
    return [NSString stringWithFormat:@"%@", object];
}

// Auth Tokens
- (void)setAccessToken:(NSDictionary *)accessToken {
    NSMutableDictionary *authTokenWithAppVersion = [[NSMutableDictionary alloc] initWithDictionary:accessToken];
    NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"];
    [authTokenWithAppVersion setValue:version forKey:@"app_version"];
    
    NSLog(@"set access token: %@", accessToken);
    
    [Lockbox archiveObject:authTokenWithAppVersion forKey:@"access_token"];
}
- (NSString *)refreshToken {
    NSDictionary *accessToken = [Lockbox unarchiveObjectForKey:@"access_token"];
    if (accessToken == nil) { return nil; }
        
    if (accessToken[@"attributes"] && accessToken[@"attributes"][@"refresh_token"] && [accessToken[@"attributes"][@"refresh_token"] isKindOfClass:[NSString class]]) {
        return accessToken[@"attributes"][@"refresh_token"];
    }
    
    return nil;
}
- (NSDictionary *)getAccessTokenWithVerification:(BOOL)verify {
    NSDictionary *accessToken =  [Lockbox unarchiveObjectForKey:@"access_token"];
    return verify ? [session verifyToken:accessToken] : accessToken;
}

- (void)signOut {
    // keep the config
    NSInteger launches = [[NSUserDefaults standardUserDefaults] integerForKey:@"launches"];
    
    // keep device token
    NSString *deviceToken = [[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"];
    
    // send DELETE request to API
    NSDictionary *accessToken = [[Session sharedInstance] getAccessTokenWithVerification:true];
    if (accessToken != nil) {
        NSLog(@"⚡️⚡️⚡️⚡️⚡️⚡️  SIGN OUT  ⚡️⚡️⚡️⚡️⚡️⚡️⚡️");
        
        [[InsightsLogger sharedInstance] uploadAllInsights];
        
        NSString *url = [NSString stringWithFormat:@"%@/%@/oauth/access_token", [Configuration API_BASE_URI], [Configuration API_CURRENT_VERSION]];
        
        NSLog(@"let's authenticate........");
        [Session authenticate:^(BOOL success, NSString *token) {
            if (success) {
                HAWebService *logoutManager = [[HAWebService alloc] init];
                                 
                [logoutManager.requestSerializer setValue:[NSString stringWithFormat:@"Bearer %@", token] forHTTPHeaderField:@"Authorization"];
                logoutManager.requestSerializer.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@"GET", @"HEAD", nil];
                
                NSLog(@"logoutManager headers: %@", [logoutManager.requestSerializer HTTPRequestHeaders]);
                NSLog(@"headers: %@", @{@"access_token": token});
                
                [logoutManager DELETE:url parameters:@{@"access_token": token} success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
                    NSLog(@"✌️ Logged out of User");
                    
                    [Launcher openOnboarding];
                } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                    NSLog(@"❌ Failed to log out of User");
                    NSString *ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
                    NSLog(@"log out error: %@", ErrorResponse);
                    
                    NSLog(@"task: %@", task);
                    NSLog(@"logoutManager? %@", logoutManager);
                }];
            }
        }];
    }
    
    // clear session
    session = nil;
    
    // reset the [HAWebService authenticatedManager]
    [HAWebService reset];
    
    // ❌🗑❌ clear local app data ❌🗑❌
    NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];
    [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];
    
    // clear cache
    [[PINCache sharedCache] removeAllObjects];
    
    // set the config again
    [[NSUserDefaults standardUserDefaults] setBool:TRUE forKey:@"kHasLaunchedBefore"];
    [[NSUserDefaults standardUserDefaults] setInteger:launches forKey:@"launches"];
    
    // set the device token again
    [[NSUserDefaults standardUserDefaults] setObject:deviceToken forKey:@"device_token"];
    
    // clear Lockbox
    [Lockbox archiveObject:nil forKey:@"access_token"];
    
    // clear notifications
    [UIApplication sharedApplication].applicationIconBadgeNumber = 0;
    
    NSLog(@"..... all done with sign out procedures ......");
}

+ (void)authenticate:(void (^)(BOOL success, NSString *token))handler {
    NSDictionary *accessToken = [session getAccessTokenWithVerification:false];
    
    // load cache of user
    if (accessToken != nil) {
        NSLog(@"access token: %@", accessToken[@"attributes"][@"access_token"]);
        handler(TRUE, accessToken[@"attributes"][@"access_token"]);
    }
    else {
        handler(false, nil);
    } 
}
- (NSDictionary *)verifyToken:(NSDictionary *)token {
    NSDate *now = [NSDate date];
    
    // compare dates to make sure both are still active
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZ"];
    
    NSDate *tokenExpiration = [formatter dateFromString:token[@"attributes"][@"expires_at"]];
    
    NSCalendar *gregorian = [[NSCalendar alloc]
                             initWithCalendarIdentifier:NSCalendarIdentifierGregorian];
    NSDateComponents *comps = [gregorian components: NSCalendarUnitMinute
                                           fromDate: [NSDate date]
                                             toDate: tokenExpiration
                                            options: 0];    
    NSLog(@"minutes until token expiration:: %ld", (long)[comps minute]);
    
    NSLog(@"token app version: %@", token[@"app_version"]);
    
    NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"];
    if ([now compare:tokenExpiration] == NSOrderedDescending || ![token[@"app_version"] isEqualToString:version]) {
        // loginExpiration in the future
        token = nil;
        
        if (![token[@"app_version"] isEqualToString:version]) {
            NSLog(@"app version has changed (%@ -> %@)", token[@"app_version"], version);
        }
    }
    
    return token;
}

- (void)getNewAccessToken:(void (^)(BOOL success, NSString *newToken))handler {
    NSLog(@"->> getNewAccessToken");
    
    // GET NEW ACCESS TOKEN
    NSDictionary *currentAccessToken = [[Session sharedInstance] getAccessTokenWithVerification:YES];
    if (currentAccessToken) {
        // access token is already valid -- must have already been refreshed
        NSLog(@"access token is already valid! must have already been refreshed");
        
        handler(true, currentAccessToken[@"attributes"][@"access_token"]);
    }
    else if ([[Session sharedInstance] refreshToken] != nil) {
        // has a seemingly valid refresh token, so we should attempt
        
        if (self.refreshTokenDispatchGroup) {
            NSLog(@"already refreshing....");
            
            NSLog(@"please hold ??");
            dispatch_group_notify(self.refreshTokenDispatchGroup, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
                NSLog(@"all requests finished!");
                NSLog(@"done refreshing and the verdict is.....");
                NSDictionary *accessToken = [[Session sharedInstance] getAccessTokenWithVerification:true];
                if (accessToken == nil) {
                    // original effort failed to get a new access token
                    NSLog(@"original effort failed");
                    handler(false, nil);
                }
                else {
                    NSLog(@"original effort SUCCEEDED WOOOOOO");
                    handler(true, accessToken[@"attributes"][@"access_token"]);
                }
            });
        }
        else {
            self.refreshTokenDispatchGroup = dispatch_group_create();
            dispatch_group_enter(self.refreshTokenDispatchGroup);
            
            // get new access token
            HAWebService *refreshTokenManager = [[HAWebService alloc] init];
            [refreshTokenManager.requestSerializer setValue:[NSString stringWithFormat:@"Bearer %@", [Configuration API_KEY]] forHTTPHeaderField:@"Authorization"];
            NSLog(@"refreshtoken [HAWebService authenticatedManager]: %@", refreshTokenManager);
            
            NSDictionary *params = @{@"grant_type": @"refresh_token", @"refresh_token": [[Session sharedInstance] refreshToken]};
            
            NSLog(@"params: %@", params);
            [refreshTokenManager POST:@"oauth" parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable accessTokenResponse) {
                NSLog(@"--------");
                NSLog(@"success: getNewAccessToken");
                NSLog(@"--------");
                
                // save new auth token
                NSDictionary *cleanDictionary = [accessTokenResponse[@"data"] clean];
                
                [[Session sharedInstance] setAccessToken:cleanDictionary];
                
                dispatch_group_leave(self.refreshTokenDispatchGroup);
                self.refreshTokenDispatchGroup = nil;
                
                handler(true, cleanDictionary[@"attributes"][@"access_token"]);
            } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                NSLog(@"/oauth error: %@", error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey]);
                NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
                NSLog(@"%@",ErrorResponse);
                
                // check if another access token was already retrieved in the mean time
                // -> this happens when you have multiple requests attempting to use an expired token and consequently, multiple requests are made to renew the access token. the subsequent requests will fail with an error code 48, due to sending an invalid token (since it has already been used for a refresh)
                
                dispatch_group_leave(self.refreshTokenDispatchGroup);
                self.refreshTokenDispatchGroup = nil;
                
                NSDictionary *accessToken = [[Session sharedInstance] getAccessTokenWithVerification:true];
                if (accessToken != nil) {
                    // already refreshed! good to go
                    NSLog(@"access token? %@", accessToken[@"attributes"][@"access_token"]);
                    handler(true, accessToken[@"attributes"][@"access_token"]);
                }
                else {
                    handler(false, nil);
                }
            }];
        }
    }
    else {
        // NSLog(@"refresh token  ==  nil");
        handler(false, nil);
    }
}

// Magic Login
// Store successful logins in the keychain
- (void)setSuccessfulEmail:(NSString *)email {
    NSMutableDictionary *successfulEmails = [[NSMutableDictionary alloc] initWithDictionary:[session getSuccessfulEmails]];
    [successfulEmails setObject:@true forKey:email];
    [Lockbox archiveObject:successfulEmails forKey:@"successful_emails"];
}
- (NSDictionary *)getSuccessfulEmails {
    if ([[Lockbox unarchiveObjectForKey:@"successful_emails"] isKindOfClass:[NSDictionary class]]) {
        return [Lockbox unarchiveObjectForKey:@"successful_emails"];
    }
    else {
        return @{};
    }
}
- (NSString *)getSuccessfulEmail {
    // TODO
    return @"";
}

- (void)resetTemporaryDefaults {
    [[NSUserDefaults standardUserDefaults] removeObjectForKey:@"temporary_defaults"];
    NSMutableDictionary *temporaryDefaults = [[NSMutableDictionary alloc] init];
    [[NSUserDefaults standardUserDefaults] setObject:temporaryDefaults forKey:@"temporary_defaults"];
}
+ (int)getTempId {
    int tempId = 1;
    NSMutableDictionary *temporaryDefaults = [[NSMutableDictionary alloc] initWithDictionary:[[NSUserDefaults standardUserDefaults] dictionaryForKey:@"temporary_defaults"]];
    if (temporaryDefaults[@"postsCreated"] != [NSNull null] && temporaryDefaults[@"postsCreated"] != nil) {
        tempId = [temporaryDefaults[@"postsCreated"] intValue] + 1;
    }
    [temporaryDefaults setObject:[NSNumber numberWithInt:tempId] forKey:@"postsCreated"];
    [[NSUserDefaults standardUserDefaults] setObject:temporaryDefaults forKey:@"temporary_defaults"];
    
    return tempId;
}

@end
