//
//  Session.m
//  Hallway App
//
//  Created by Austin Valleskey on 6/16/18.
//  Copyright © 2018 Hallway App. All rights reserved.
//

#import "Session.h"

#import "Launcher.h"
#import "AppDelegate.h"
#import <Lockbox/Lockbox.h>
#import "NSDictionary+Clean.h"
#import "HAWebService.h"
#import "Room.h"
#import "UIColor+Palette.h"
#import <Tweaks/FBTweakInline.h>
#import "NSDictionary+Clean.h"
#import "NSArray+Clean.h"
#import <PINCache/PINCache.h>
#import "InsightsLogger.h"

@interface Session ()

@end

@implementation Session

static Session *session;

+ (Session *)sharedInstance {
    if (!session) {
        session = [[Session alloc] init];
        
        // init AFNetworking session manager
        [session initManager];
        [session initDefaults];
        
        if ([[NSUserDefaults standardUserDefaults] objectForKey:@"user_device_token"]) {
            // "user_device_token"  = the device token that is currently associated with a user
            // "device_token"       = the latest device token received/generated by the device
            session.deviceToken = [[NSUserDefaults standardUserDefaults] stringForKey:@"user_device_token"];
        }
        
        if ([[NSUserDefaults standardUserDefaults] objectForKey:@"user"]) {
            session.currentUser = [[User alloc] initWithData:[[NSUserDefaults standardUserDefaults] objectForKey:@"user"] error:nil];
            NSLog(@"🙎‍♂️ User: @%@", session.currentUser.attributes.details.identifier);
        }
        
        if ([session getAccessTokenWithVerification:true] != nil && session.currentUser.identifier != nil) {
            // update user object
            [session fetchUser:^(BOOL success) {
                
            }];
            [session syncDeviceToken];
        }
        
        [session resetTemporaryDefaults];
    }
    return session;
}

- (void)initManager {
    session.manager = [HAWebService manager];
    
    [[NSNotificationCenter defaultCenter] addObserver:session selector:@selector(HTTPOperationDidFinish:) name:AFNetworkingTaskDidCompleteNotification object:nil];
}
- (void)initDefaults {
    if([[NSUserDefaults standardUserDefaults] dictionaryForKey:@"app_defaults"] == nil) {
        NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@"LocalDefaults" ofType:@"json"];
        NSData *data = [NSData dataWithContentsOfFile:bundlePath];
        NSDictionary *json = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil];
        
        [session updateDefaultsJSON:json];
    }

    NSError* error;
    NSDictionary* dictionaryJSON = [[NSUserDefaults standardUserDefaults] dictionaryForKey:@"app_defaults"];
    
    session.defaults = [[Defaults alloc] initWithDictionary:dictionaryJSON error:&error];
    if (error) {
        NSLog(@"⚠️ session defaults error: %@", error);
    }
    
    // get new defaults!!
    NSString *url = [NSString stringWithFormat:@"%@/%@/clients/defaults.json", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"]];
    [session.manager GET:url parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSError *error;
        Defaults *newDefaults = [[Defaults alloc] initWithDictionary:responseObject error:&error];

        if (!error) {
            session.defaults = newDefaults;
            
            // save to local file
            [session updateDefaultsJSON:responseObject];
        }
        else {
            NSLog(@"⚠️ error with new json: %@", error);
        }
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSLog(@"😞 darn. error getting the new defaults");
        NSString *ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
        NSLog(@"errorResponse: %@", ErrorResponse);
        NSLog(@"---------");
    }];
    
    // Customize defaults via Tweaks
    #ifdef DEBUG
    //[self enableCustomizableDefaults];
    #endif
}
- (void)updateDefaultsJSON:(NSDictionary *)json {
    [[NSUserDefaults standardUserDefaults] setObject:[json clean] forKey:@"app_defaults"];
}
- (void)enableCustomizableDefaults {
    FBTweakStore *store = [FBTweakStore sharedInstance];
    FBTweakCategory *category = [[FBTweakCategory alloc] initWithName:@"System Defaults"];
    [store addTweakCategory:category];
    
    FBTweakCollection *profileCollection = [[FBTweakCollection alloc] initWithName:@"Profile"];
    [profileCollection addTweak:[self createTweakWithIdentifier:@"follow_verb" defaultValue:session.defaults.profile.followVerb]];
    [profileCollection addTweak:[self createTweakWithIdentifier:@"following_verb" defaultValue:session.defaults.profile.followingVerb]];
    [category addTweakCollection:profileCollection];
    
    FBTweakCollection *postCollection = [[FBTweakCollection alloc] initWithName:@"Post"];
    [postCollection addTweak:[self createTweakWithIdentifier:@"vote_text" defaultValue:session.defaults.post.displayVote.text]];
    [postCollection addTweak:[self createTweakWithIdentifier:@"vote_icon" defaultValue:session.defaults.post.displayVote.icon]];
    [postCollection addTweak:[self createTweakWithIdentifier:@"image_height" defaultValue:[NSNumber numberWithInteger:session.defaults.post.imgHeight]]];
    [postCollection addTweak:[self createTweakWithIdentifier:@"max_length" defaultValue:[NSNumber numberWithInteger:session.defaults.post.maxLength]]];
    [postCollection addTweak:[self createTweakWithIdentifier:@"compose_prompt" defaultValue:session.defaults.post.composePrompt]];
    [category addTweakCollection:postCollection];
    
    FBTweakCollection *roomCollection = [[FBTweakCollection alloc] initWithName:@"Room"];
    [roomCollection addTweak:[self createTweakWithIdentifier:@"create_verb" defaultValue:session.defaults.post.displayVote.text]];
    [roomCollection addTweak:[self createTweakWithIdentifier:@"follow_verb" defaultValue:session.defaults.post.displayVote.icon]];
    [roomCollection addTweak:[self createTweakWithIdentifier:@"following_verb" defaultValue:[NSNumber numberWithInteger:session.defaults.post.imgHeight]]];
    [roomCollection addTweak:[self createTweakWithIdentifier:@"max_length" defaultValue:[NSNumber numberWithInteger:session.defaults.post.maxLength]]];
    [roomCollection addTweak:[self createTweakWithIdentifier:@"max_length" defaultValue:[NSNumber numberWithInteger:session.defaults.post.maxLength]]];
    [roomCollection addTweak:[self createTweakWithIdentifier:@"compose_prompt" defaultValue:session.defaults.post.composePrompt]];
    [category addTweakCollection:roomCollection];
}
- (FBTweak *)createTweakWithIdentifier:(NSString *)identifier defaultValue:(id)defaultValue {
    FBTweak *tweak = [[FBTweak alloc] initWithIdentifier:[NSString stringWithFormat:@"com.tweaks.defaults.%@", identifier]];
    tweak.name = [[identifier stringByReplacingOccurrencesOfString:@"_" withString:@" "] localizedCapitalizedString];
    tweak.defaultValue = defaultValue;
    
    return tweak;
}

// app-wide error code handling
- (void)HTTPOperationDidFinish:(NSNotification *)notification {
    NSError *error = [notification.userInfo objectForKey:AFNetworkingTaskDidCompleteErrorKey];
    NSHTTPURLResponse *httpResponse = error.userInfo[AFNetworkingOperationFailingURLResponseErrorKey];
    NSInteger statusCode = httpResponse.statusCode;
    
    if (statusCode != 0) {        
        // NSLog(@"status code:: %ld", (long)statusCode);
        
        if (statusCode == BAD_AUTHENTICATION) {
            NSLog(@"40: BAD AUTHENTICATION");
            // try getting new auth token
            [session getNewAcessToken:^(BOOL success, NSString *newToken) {
                if (success) {
                    //NSLog(@"successfully got new access token: %@", newToken);
                }
                else {
                    NSLog(@"bad token");
                    //[session signOut];
                    
                    [[Launcher sharedInstance] openOnboarding];
                }
            }];
        }
        else if (statusCode == BAD_REFRESH_TOKEN || statusCode == BAD_REFRESH_LOGIN_REQ) {
            [session signOut];
            
            [[Launcher sharedInstance] openOnboarding];
        }
    }
}

- (UIColor *)themeColor {
    return [[session.currentUser.attributes.details.color lowercaseString] isEqualToString:@"ffffff"] ? [UIColor colorWithWhite:0.2f alpha:1] : [UIColor fromHex:session.currentUser.attributes.details.color.length > 0 ? session.currentUser.attributes.details.color : @"7d8a99"];
}

- (void)syncDeviceToken {
    // "user_device_token"  = the device token that is currently associated with a user
    // "device_token"       = the latest device token received/generated by the device
    if (session.currentUser && [[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"] && ![[[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"] isEqualToString:[[NSUserDefaults standardUserDefaults] stringForKey:@"user_device_token"]]) {
        // has device token and it isn't equal the user_device_token
        NSLog(@"🚨 user has a new device token -> we need to register it");
                
        NSString *url = [NSString stringWithFormat:@"%@/%@/users/me/notifications/token", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"]];
        
        [session authenticate:^(BOOL success, NSString *token) {
            [session.manager.requestSerializer setValue:[NSString stringWithFormat:@"Bearer %@", token] forHTTPHeaderField:@"Authorization"];
            
            [session.manager POST:url parameters:@{@"system": @"apns", @"token": [[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"]} progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
                NSLog(@"🤪 successfully updated the device token for @%@", session.currentUser.attributes.details.identifier);
                [[NSUserDefaults standardUserDefaults] setObject:[[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"] forKey:@"user_device_token"];
                
                session.deviceToken = [[NSUserDefaults standardUserDefaults] stringForKey:@"device_token"];
            } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                NSLog(@"😞 darn. error updating the device token");
                // NSString *ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
            }];
        }];
    }
    else {
        NSLog(@"sync device token didn't qualify");
    }
}

// User
- (void)updateUser:(User *)newUser {
    [[NSUserDefaults standardUserDefaults] setObject:[newUser toJSONData] forKey:@"user"];
    
    session.currentUser = newUser;
    [[NSNotificationCenter defaultCenter] postNotificationName:@"UserUpdated" object:newUser];
}
- (void)fetchUser:(void (^)(BOOL success))handler {
    NSDictionary *accessToken = [session getAccessTokenWithVerification:true];

    if (accessToken != nil) {
        NSString *url = [NSString stringWithFormat:@"%@/%@/users/me", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"]];
        
        NSLog(@"session.manager: %@", session.manager);
        [session.manager.requestSerializer setValue:[NSString stringWithFormat:@"Bearer %@", accessToken[@"attributes"][@"access_token"]] forHTTPHeaderField:@"Authorization"];
        [session.manager GET:url parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
            NSError *error;
            
            User *user = [[User alloc] initWithDictionary:responseObject[@"data"] error:&error];
            if (error) { NSLog(@"GET -> /users/me; User error: %@", error); }
            
            [session updateUser:user];
            
            handler(TRUE);
        } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
            NSLog(@"❌ Failed to get User ID");
            NSString *ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
            NSLog(@"%@", ErrorResponse);
            
            handler(FALSE);
        }];
    }
    
    handler(FALSE);
}

- (void)addToRecents:(id)object {
    if ([object isKindOfClass:[Room class]] ||
        [object isKindOfClass:[User class]]) {
        NSMutableArray *searchRecents = [[NSMutableArray alloc] initWithArray:[[NSUserDefaults standardUserDefaults] arrayForKey:@"recents_search"]];
        
        NSDictionary *objJSON = [object toDictionary];
        
        if ([object isKindOfClass:[Room class]]) {
            [self incrementOpensForRoom:(Room *)object];
        }
        
        // add object or push to front if in recents
        BOOL existingMatch = false;
        for (NSInteger i = 0; i < [searchRecents count]; i++) {
            NSDictionary *result = searchRecents[i];
            if (objJSON[@"type"] && objJSON[@"id"] &&
                result[@"type"] && result[@"id"]) {
                if ([objJSON[@"type"] isEqualToString:result[@"type"]] && [[self convertToString:objJSON[@"id"]] isEqualToString:[self convertToString:result[@"id"]]]) {
                    existingMatch = true;
                    
                    [searchRecents removeObjectAtIndex:i];
                    [searchRecents insertObject:objJSON atIndex:0];
                    break;
                }
            }
        }
        if (!existingMatch) {
            // remove context first
            if ([object isKindOfClass:[Room class]]) {
                Room *room = (Room *)object;
                //room.attributes.context = nil;
                
                [searchRecents insertObject:[room toDictionary] atIndex:0];
            }
            else if ([object isKindOfClass:[User class]]) {
                User *user = (User *)object;
                //user.attributes.context = nil;
                
                [searchRecents insertObject:[user toDictionary] atIndex:0];
            }
            
            NSMutableArray *removeObjects = [[NSMutableArray alloc] init];
            NSInteger numOfRooms = 0;
            NSInteger numOfUsers = 0;
            for (NSDictionary *object in searchRecents) {
                if ([object isKindOfClass:[NSDictionary class]] && [object[@"type"] isKindOfClass:[NSString class]]) {
                    if ([object[@"type"] isEqualToString:@"room"]) {
                        numOfRooms = numOfRooms + 1;
                        if (numOfRooms > 16) {
                            [removeObjects addObject:object];
                        }
                    }
                    if ([object[@"type"] isEqualToString:@"user"]) {
                        numOfUsers = numOfUsers + 1;
                        if (numOfUsers > 16) {
                            [removeObjects addObject:object];
                        }
                    }
                }
            }
            [searchRecents removeObjectsInArray:removeObjects];
        }
        
        // update NSUserDefaults
        [[NSUserDefaults standardUserDefaults] setObject:[searchRecents clean] forKey:@"recents_search"];
        [[NSNotificationCenter defaultCenter] postNotificationName:@"RecentsUpdated" object:nil];
    }
}
- (void)incrementOpensForRoom:(Room *)room {
    NSMutableDictionary *opens = [[NSMutableDictionary alloc] initWithDictionary:[[NSUserDefaults standardUserDefaults] dictionaryForKey:@"room_opens"]];
    
    // set
    NSInteger opensForRoom = [opens objectForKey:room.identifier] ? [opens[room.identifier] integerValue] : 0;
    opensForRoom = opensForRoom + 1;
    [opens setObject:[NSNumber numberWithInteger:opensForRoom] forKey:room.identifier];
    
    // save
    [[NSUserDefaults standardUserDefaults] setObject:opens forKey:@"room_opens"];
}
- (NSString *)convertToString:(id)object {
    return [NSString stringWithFormat:@"%@", object];
}

// Auth Tokens
- (void)setAccessToken:(NSDictionary *)accessToken {
    NSMutableDictionary *authTokenWithAppVersion = [[NSMutableDictionary alloc] initWithDictionary:accessToken];
    NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"];
    [authTokenWithAppVersion setValue:version forKey:@"app_version"];
    
    NSLog(@"set access token: %@", accessToken);
    
    [Lockbox archiveObject:authTokenWithAppVersion forKey:@"access_token"];
    
    
}
- (NSString *)refreshToken {
    NSDictionary *accessToken = [Lockbox unarchiveObjectForKey:@"access_token"];
    if (accessToken == nil) { return nil; }
    
    if (accessToken[@"attributes"] && accessToken[@"attributes"][@"refresh_token"] && [accessToken[@"attributes"][@"refresh_token"] isKindOfClass:[NSString class]]) {
        return accessToken[@"attributes"][@"refresh_token"];
    }
    
    return nil;
}
- (NSDictionary *)getAccessTokenWithVerification:(BOOL)verify {
    NSDictionary *accessToken =  [Lockbox unarchiveObjectForKey:@"access_token"];
    return verify ? [session verifyToken:accessToken] : accessToken;
}

- (void)signOut {
    // close off all insights
    NSLog(@"⚡️⚡️⚡️⚡️⚡️⚡️  SIGN OUT  ⚡️⚡️⚡️⚡️⚡️⚡️⚡️");

    // send DELETE request to API
    if ([[Session sharedInstance] getAccessTokenWithVerification:true] != nil) {
        [[InsightsLogger sharedInstance] uploadAllInsights];
        
        NSString *url = [NSString stringWithFormat:@"%@/%@/oauth/access_token", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"]];
        
        [session authenticate:^(BOOL success, NSString *token) {
            if (success) {
                [session.manager.requestSerializer setValue:[NSString stringWithFormat:@"Bearer %@", token] forHTTPHeaderField:@"Authorization"];

                NSLog(@"headers... : %@", session.manager.requestSerializer.HTTPRequestHeaders);
                
                [session.manager DELETE:url parameters:@{@"access_token": token} success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
                    NSLog(@"✌️ Logged out of User");
                } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                    NSLog(@"❌ Failed to log out of User");
                    NSString *ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
                    NSLog(@"%@", ErrorResponse);
                }];
            }
        }];
    }
    
    // keep the config
    NSString *environment = [[NSUserDefaults standardUserDefaults] stringForKey:@"environment"];
    NSDictionary *config = [[NSUserDefaults standardUserDefaults] dictionaryForKey:@"config"];
    NSInteger launches = [[NSUserDefaults standardUserDefaults] integerForKey:@"launches"];
    
    // keep device token
    NSString *deviceToken = session.deviceToken;
    
    // clear session
    session = nil;
    
    // ❌🗑❌ clear local app data ❌🗑❌
    NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];
    [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];
    
    // clear cache
    [[PINCache sharedCache] removeAllObjects];
    
    // set the config again
    [[NSUserDefaults standardUserDefaults] setObject:environment forKey:@"environment"];
    [[NSUserDefaults standardUserDefaults] setObject:config forKey:@"config"];
    [[NSUserDefaults standardUserDefaults] setBool:TRUE forKey:@"kFirstLaunch"];
    [[NSUserDefaults standardUserDefaults] setInteger:launches forKey:@"launches"];
    
    // set the device token again
    [[NSUserDefaults standardUserDefaults] setObject:deviceToken forKey:@"device_token"];
    
    // clear Lockbox
    [Lockbox archiveObject:nil forKey:@"access_token"];
    
    NSLog(@"..... ADIOSSSS AMIGO ......");
}

- (void)authenticate:(void (^)(BOOL success, NSString *token))handler {
    NSDictionary *accessToken = [session getAccessTokenWithVerification:false];
    NSDictionary *verifiedAccessToken = [session getAccessTokenWithVerification:true];
    
    // load cache of user
    if (verifiedAccessToken != nil) {
        handler(TRUE, accessToken[@"attributes"][@"access_token"]);
    }
    else if (accessToken[@"attributes"] && accessToken[@"attributes"][@"refresh_token"] && [accessToken[@"attributes"][@"refresh_token"] isKindOfClass:[NSString class]]) {
        NSLog(@"refresh token exists");
        // refresh token exists -> use it to get a new access token
        [session getNewAcessToken:^(BOOL success, NSString *newToken) {
            if (success) {
                handler(true, newToken);
            }
            else {
                NSLog(@"bad token");
                [session signOut];
                
                [[Launcher sharedInstance] openOnboarding];
            }
        }];
    }
    else {
        handler(false, nil);
    }
}
- (NSDictionary *)verifyToken:(NSDictionary *)token {
    NSDate *now = [NSDate date];
    
    // compare dates to make sure both are still active
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZ"];
    
    NSDate *tokenExpiration = [formatter dateFromString:token[@"attributes"][@"expires_at"]];
    
    NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"];
    if ([now compare:tokenExpiration] == NSOrderedDescending || ![token[@"app_version"] isEqualToString:version]) {
        // loginExpiration in the future
        token = nil;
        
        NSLog(@"token is expired");
    }
    
    return token;
}

- (void)getNewAcessToken:(void (^)(BOOL success, NSString *newToken))handler {
    NSLog(@"->> getNewAcessToken");
    
    // GET NEW ACCESS TOKEN
    if ([Session sharedInstance].refreshToken != nil) {
        NSString *url = [NSString stringWithFormat:@"%@/%@/oauth", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"]];
        NSDictionary *params = @{@"grant_type": @"refresh_token", @"refresh_token": [Session sharedInstance].refreshToken};
        
        // set defaults
        [session.manager.requestSerializer setValue:[NSString stringWithFormat:@"Bearer %@", envConfig[@"API_KEY"]] forHTTPHeaderField:@"Authorization"];
        [session.manager.requestSerializer setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
        
        [session.manager POST:url parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable accessTokenResponse) {
            NSLog(@"--------");
            NSLog(@"success: getNewAccessToken");
            NSLog(@"--------");
            
            // save new auth token
            NSDictionary *cleanDictionary = [accessTokenResponse[@"data"] clean];
            
            [[Session sharedInstance] setAccessToken:cleanDictionary];
            
            handler(true, cleanDictionary[@"attributes"][@"access_token"]);
        } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
            NSLog(@"error: %@", error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey]);
            NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
            NSLog(@"%@",ErrorResponse);
            
            // check if another access token was already retrieved in the mean time
            // -> this happens when you have multiple requests attempting to use an expired token and consequently, multiple requests are made to renew the access token. the subsequent requests will fail with an error code 48, due to sending an invalid token (since it has already been used for a refresh)
            NSDictionary *accessToken = [[Session sharedInstance] getAccessTokenWithVerification:true];
            if (accessToken != nil) {
                NSLog(@"already refreshed! good to go.");
                handler(true, accessToken[@"attributes"][@"access_token"]);
            }
            else {
                NSLog(@"access token  ==  nil");
                
                handler(false, nil);
            }
        }];
    }
    else {
        NSLog(@"refresh token  ==  nil");
        handler(false, nil);
    }
}

// Magic Login
// Store successful logins in the keychain
- (void)setSuccessfulEmail:(NSString *)email {
    NSMutableDictionary *successfulEmails = [[NSMutableDictionary alloc] initWithDictionary:[session getSuccessfulEmails]];
    [successfulEmails setObject:@true forKey:email];
    [Lockbox archiveObject:successfulEmails forKey:@"successful_emails"];
}
- (NSDictionary *)getSuccessfulEmails {
    if ([[Lockbox unarchiveObjectForKey:@"successful_emails"] isKindOfClass:[NSDictionary class]]) {
        return [Lockbox unarchiveObjectForKey:@"successful_emails"];
    }
    else {
        return @{};
    }
}
- (NSString *)getSuccessfulEmail {
    // TODO
    return @"";
}

- (void)resetTemporaryDefaults {
    [[NSUserDefaults standardUserDefaults] removeObjectForKey:@"temporary_defaults"];
    NSMutableDictionary *temporaryDefaults = [[NSMutableDictionary alloc] init];
    [[NSUserDefaults standardUserDefaults] setObject:temporaryDefaults forKey:@"temporary_defaults"];
}
- (int)getTempId {
    int tempId = 1;
    NSMutableDictionary *temporaryDefaults = [[NSMutableDictionary alloc] initWithDictionary:[[NSUserDefaults standardUserDefaults] dictionaryForKey:@"temporary_defaults"]];
    if (temporaryDefaults[@"postsCreated"] != [NSNull null] && temporaryDefaults[@"postsCreated"] != nil) {
        tempId = [temporaryDefaults[@"postsCreated"] intValue] + 1;
    }
    [temporaryDefaults setObject:[NSNumber numberWithInt:tempId] forKey:@"postsCreated"];
    [[NSUserDefaults standardUserDefaults] setObject:temporaryDefaults forKey:@"temporary_defaults"];
    
    return tempId;
}

// Actions
// -- Post --
- (void)createPost:(NSDictionary *)params postingIn:(Room *)postingIn replyingTo:(Post * _Nullable)replyingTo {    
    // CREATE TEMP POST
    // --> This will place a temporary post at the top of related streams
    // --> Once the post has been created, we send a notification telling the View Controllers to remove the temporary post and replace it with the new post
    Post *tempPost = [[Post alloc] init];
    [tempPost createTempWithMessage:params[@"message"] images:params[@"images"] postedIn:postingIn parent:replyingTo.identifier];
    [[NSNotificationCenter defaultCenter] postNotificationName:@"NewPostBegan" object:tempPost];

    [self uploadImages:params[@"images"] copmletion:^(BOOL imageSuccess, NSArray *images) {
        if (imageSuccess) {
            [[Session sharedInstance] authenticate:^(BOOL success, NSString *token) {
                if (success) {
                    NSLog(@"token::: %@", token);
                    NSString *url;
                    if ([postingIn isKindOfClass:[Room class]]) {
                        // post in Room
                        Room *room = postingIn;
                        if (replyingTo) {
                            url = [NSString stringWithFormat:@"%@/%@/rooms/%@/posts/%ld/replies", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], room.identifier, replyingTo.identifier];
                        }
                        else {
                            url = [NSString stringWithFormat:@"%@/%@/rooms/%@/posts", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], room.identifier];
                        }
                    }
                    else {
                        // post to user profile
                        if (replyingTo) {
                            User *user = replyingTo.attributes.details.creator;
                            NSLog(@"reply to @%@", user.attributes.details.identifier);
                            url = [NSString stringWithFormat:@"%@/%@/users/%@/posts/%ld/replies", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], user.identifier, replyingTo.identifier];
                        }
                        else {
                            url = [NSString stringWithFormat:@"%@/%@/users/me/posts", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"]];
                        }
                    }
                    
                    NSLog(@"params: %@", params);
                    NSMutableDictionary *mutableParams = [[NSMutableDictionary alloc] initWithDictionary:params];
                    if ([params objectForKey:@"images"] && images.count != 0) {
                        [mutableParams setObject:images forKey:@"images"];
                    }
                    else {
                        [mutableParams removeObjectForKey:@"image"];
                    }
                    
                    [session.manager.requestSerializer setValue:@"application/json" forHTTPHeaderField:@"Content-Type"];
                    [session.manager.requestSerializer setValue:[NSString stringWithFormat:@"Bearer %@", token] forHTTPHeaderField:@"Authorization"];
                    session.manager.responseSerializer = [AFJSONResponseSerializer serializer];
                    [session.manager POST:url parameters:mutableParams progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
                        // NSLog(@"CommonTableViewController / getPosts() success! ✅");
                        
                        NSError *postError;
                        Post *post = [[Post alloc] initWithDictionary:responseObject[@"data"] error:&postError];
                        
                        [[NSNotificationCenter defaultCenter] postNotificationName:@"NewPostCompleted" object:@{@"tempId": tempPost.tempId, @"post": post}];
                    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                        NSLog(@"Session / createPost() - error: %@", error);
                        // NSString *ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
                        
                        [[NSNotificationCenter defaultCenter] postNotificationName:@"NewPostFailed" object:tempPost];
                    }];
                }
            }];
        }
        else {
            
        }
    }];
}
- (void)deletePost:(Post *)post completion:(void (^)(BOOL success, id responseObject))handler {
    NSString *url;
    if (post.attributes.status.postedIn) {
        // posted in a room
        url = [NSString stringWithFormat:@"%@/%@/rooms/%@/posts/%ld", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], post.attributes.status.postedIn.identifier, (long)post.identifier];
    }
    else {
        // posted on a profile
        url = [NSString stringWithFormat:@"%@/%@/users/%@/posts/%ld", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], post.attributes.details.creator.attributes.details.identifier, (long)post.identifier];
    }
    NSDictionary *params = @{};
    
    NSLog(@"url:: %@", url);
    
    [session.manager.requestSerializer setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    [session.manager DELETE:url parameters:params success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSLog(@"--------");
        NSLog(@"success: delete post");
        NSLog(@"--------");
        
        handler(true, responseObject);
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
        NSLog(@"%@",ErrorResponse);
        
        handler(false, @{@"error": ErrorResponse});
    }];
    
    [[NSNotificationCenter defaultCenter] postNotificationName:@"PostDeleted" object:post];
}
- (void)reportPost:(NSInteger)postId completion:(void (^)(BOOL success, id responseObject))handler {
    handler(true, @{});
}
- (void)sparkPost:(Post *)post completion:(void (^)(BOOL success, id responseObject))handler {
    NSString *url;
    if (post.attributes.status.postedIn) {
        // posted in a room
        url = [NSString stringWithFormat:@"%@/%@/rooms/%@/posts/%ld/votes", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], post.attributes.status.postedIn.identifier, (long)post.identifier];
    }
    else {
        // posted on a profile
        url = [NSString stringWithFormat:@"%@/%@/users/%@/posts/%ld/votes", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], post.attributes.details.creator.attributes.details.identifier, (long)post.identifier];
    }
    
    NSDictionary *params = @{};
    
    NSLog(@"url:: %@", url);
    
    [session.manager.requestSerializer setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    [session.manager POST:url parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSLog(@"--------");
        NSLog(@"success: upvote");
        NSLog(@"--------");
        
        handler(true, responseObject);
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
        NSLog(@"%@",ErrorResponse);
        
        handler(false, @{@"error": ErrorResponse});
    }];
    
    // update the UI
    NSDateFormatter *gmtDateFormatter = [[NSDateFormatter alloc] init];
    gmtDateFormatter.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0];
    gmtDateFormatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ssZ";
    NSString *dateString = [gmtDateFormatter stringFromDate:[NSDate new]];
    
    PostContextVote *voteDict = [[PostContextVote alloc] initWithDictionary:@{@"created_at": dateString} error:nil];
    post.attributes.context.vote = voteDict;
    
    [[NSNotificationCenter defaultCenter] postNotificationName:@"PostUpdated" object:post];
}
- (void)unsparkPost:(Post *)post completion:(void (^)(BOOL success, id responseObject))handler {
    NSString *url;
    if (post.attributes.status.postedIn) {
        // posted in a room
        url = [NSString stringWithFormat:@"%@/%@/rooms/%@/posts/%ld/votes", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], post.attributes.status.postedIn.identifier, (long)post.identifier];
    }
    else {
        // posted on a profile
        url = [NSString stringWithFormat:@"%@/%@/users/%@/posts/%ld/votes", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], post.attributes.details.creator.attributes.details.identifier, (long)post.identifier];
    }
    NSDictionary *params = @{};
    
    [session.manager.requestSerializer setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    [session.manager DELETE:url parameters:params success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSLog(@"--------");
        NSLog(@"success: downvote");
        NSLog(@"--------");
        
        handler(true, responseObject);
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
        NSLog(@"%@",ErrorResponse);
        
        handler(false, @{@"error": ErrorResponse});
    }];
    
    // update the UI
    NSMutableDictionary *contextDict = [[NSMutableDictionary alloc] initWithDictionary:[post.attributes.context toDictionary]];
    [contextDict removeObjectForKey:@"vote"];
    PostContext *newContext = [[PostContext alloc] initWithDictionary:contextDict error:nil];
    post.attributes.context = newContext;
    
    [[NSNotificationCenter defaultCenter] postNotificationName:@"PostUpdated" object:post];
}


// -- Follow/Unfollow User --
- (void)followUser:(User *)user completion:(void (^)(BOOL success, id responseObject))handler {
    NSString *url = [NSString stringWithFormat:@"%@/%@/users/%@/follow", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], user.identifier]; // sample data
    
    NSLog(@"url: %@", url);
    
    [session.manager.requestSerializer setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    [session.manager POST:url parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSLog(@"--------");
        NSLog(@"success: followUser");
        NSLog(@"--------");
        
        // refresh user object
        // [[NSNotificationCenter defaultCenter] postNotificationName:@"refreshMyRooms" object:nil];
        
        //NSError *error;
        //RoomContext *roomContextResponse = [[RoomContext alloc] initWithDictionary:responseObject[@"data"] error:&error];
        
        //if (!error) { NSLog(@"room context reponse:"); NSLog(@"%@", roomContextResponse); };
        
        handler(true, @{@"following": @true});
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSLog(@"error: %@", error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey]);
        NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
        NSLog(@"%@",ErrorResponse);
        
        handler(false, @{@"error": ErrorResponse});
    }];
}
- (void)unfollowUser:(User *)user completion:(void (^)(BOOL success, id responseObject))handler {
    NSString *url = [NSString stringWithFormat:@"%@/%@/users/%@/follow", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], user.identifier]; // sample data
    
    [session.manager.requestSerializer setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    [session.manager DELETE:url parameters:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSLog(@"--------");
        NSLog(@"success: unfollowUser");
        NSLog(@"--------");
        
        // refresh user object
        // [[NSNotificationCenter defaultCenter] postNotificationName:@"refreshMyRooms" object:nil];
        
        //NSError *error;
        //RoomContext *roomContextResponse = [[RoomContext alloc] initWithDictionary:responseObject[@"data"] error:&error];
        
        //if (!error) { NSLog(@"room context reponse:"); NSLog(@"%@", roomContextResponse); };
        
        handler(true, @{@"following": @false});
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSLog(@"error: %@", error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey]);
        NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
        NSLog(@"%@",ErrorResponse);
        
        handler(false, @{@"error": ErrorResponse});
    }];
}
- (void)blockUser:(User *)user completion:(void (^)(BOOL success, id responseObject))handler {
    NSString *url = [NSString stringWithFormat:@"%@/%@/users/%@/block", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], user.identifier]; // sample data
    
    [session.manager.requestSerializer setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    [session.manager POST:url parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSLog(@"--------");
        NSLog(@"success: unblockUser");
        NSLog(@"--------");
        
        // refresh user object
        // [[NSNotificationCenter defaultCenter] postNotificationName:@"refreshMyRooms" object:nil];
        
        //NSError *error;
        //RoomContext *roomContextResponse = [[RoomContext alloc] initWithDictionary:responseObject[@"data"] error:&error];
        
        //if (!error) { NSLog(@"room context reponse:"); NSLog(@"%@", roomContextResponse); };
        
        handler(true, @{@"blocked": @false});
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSLog(@"error: %@", error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey]);
        NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
        NSLog(@"%@",ErrorResponse);
        
        handler(false, @{@"error": ErrorResponse});
    }];
}
- (void)unblockUser:(User *)user completion:(void (^)(BOOL success, id responseObject))handler {
    NSString *url = [NSString stringWithFormat:@"%@/%@/users/%@/unblock", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], user.identifier]; // sample data
    
    [session.manager.requestSerializer setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    [session.manager POST:url parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSLog(@"--------");
        NSLog(@"success: unblockUser");
        NSLog(@"--------");
        
        // refresh user object
        // [[NSNotificationCenter defaultCenter] postNotificationName:@"refreshMyRooms" object:nil];
        
        //NSError *error;
        //RoomContext *roomContextResponse = [[RoomContext alloc] initWithDictionary:responseObject[@"data"] error:&error];
        
        //if (!error) { NSLog(@"room context reponse:"); NSLog(@"%@", roomContextResponse); };
        
        handler(true, @{@"blocked": @false});
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSLog(@"error: %@", error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey]);
        NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
        NSLog(@"%@",ErrorResponse);
        
        handler(false, @{@"error": ErrorResponse});
    }];
}
- (void)reportUser:(User *)user completion:(void (^)(BOOL success, id responseObject))handler {
    NSString *url = [NSString stringWithFormat:@"%@/%@/users/%@/report", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], user.identifier]; // sample data
    
    // -> report also blocks the user
    
    [session.manager.requestSerializer setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    [session.manager POST:url parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        NSLog(@"--------");
        NSLog(@"success: reportUser");
        NSLog(@"--------");
        
        // refresh user object
        
        //NSError *error;
        //RoomContext *roomContextResponse = [[RoomContext alloc] initWithDictionary:responseObject[@"data"] error:&error];
        
        //if (!error) { NSLog(@"room context reponse:"); NSLog(@"%@", roomContextResponse); };
        
        handler(true, @{@"reported": @true});
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        NSLog(@"error: %@", error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey]);
        NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
        NSLog(@"%@",ErrorResponse);
        
        handler(false, @{@"error": ErrorResponse});
    }];
}


// -- Follow/Unfollow Room --
- (void)followRoom:(NSString *)roomId completion:(void (^)(BOOL success, id responseObject))handler {
    NSString *url = [NSString stringWithFormat:@"%@/%@/rooms/%@/members", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], roomId];
    NSDictionary *params = @{};
    
    [session.manager.requestSerializer setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    [session authenticate:^(BOOL success, NSString *token) {
        [session.manager.requestSerializer setValue:[NSString stringWithFormat:@"Bearer %@", token] forHTTPHeaderField:@"Authorization"];
        
        [session.manager POST:url parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
            NSLog(@"--------");
            NSLog(@"success: followRoom");
            NSLog(@"--------");
            
            // refresh my rooms
            [[NSNotificationCenter defaultCenter] postNotificationName:@"refreshMyRooms" object:nil];
            
            NSError *error;
            RoomContext *roomContextResponse = [[RoomContext alloc] initWithDictionary:responseObject[@"data"] error:&error];
            
            if (!error) { NSLog(@"room context reponse:"); NSLog(@"%@", roomContextResponse); };
            
            handler(true, roomContextResponse);
        } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
            NSLog(@"error: %@", error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey]);
            NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
            NSLog(@"%@",ErrorResponse);
            
            handler(false, @{@"error": ErrorResponse});
        }];
    }];
}
- (void)unfollowRoom:(NSString *)roomId completion:(void (^)(BOOL success, id responseObject))handler {
    NSString *url = [NSString stringWithFormat:@"%@/%@/rooms/%@/members", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"], roomId];
    NSDictionary *params = @{};
    
    [session.manager.requestSerializer setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    
    [session authenticate:^(BOOL success, NSString *token) {
        [session.manager.requestSerializer setValue:[NSString stringWithFormat:@"Bearer %@", token] forHTTPHeaderField:@"Authorization"];
        
        [session.manager DELETE:url parameters:params success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
            NSLog(@"--------");
            NSLog(@"success: unfollowRoom");
            NSLog(@"--------");
            
            // refresh my rooms
            [[NSNotificationCenter defaultCenter] postNotificationName:@"refreshMyRooms" object:nil];
            
            NSError *error;
            RoomContext *roomContextResponse = [[RoomContext alloc] initWithDictionary:responseObject[@"data"] error:&error];
            roomContextResponse.status = ROOM_STATUS_LEFT;
            
            if (!error) { NSLog(@"room context reponse:"); NSLog(@"%@", roomContextResponse); };
            
            handler(true, roomContextResponse);
        } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
            NSLog(@"error: %@", error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey]);
            NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
            NSLog(@"%@",ErrorResponse);
            
            handler(false, @{@"error": ErrorResponse});
        }];
    }];
}

#pragma Mutli-Use Methods
- (void)uploadImages:(NSArray *)images copmletion:(void (^)(BOOL success, NSArray *uploadedImages))handler {
    __block NSUInteger remaining = images.count;
    NSMutableArray *uploadedImages = [[NSMutableArray alloc] init];
    
    if (remaining == 0) {
        handler(true, nil);
    }
    
    for (int i = 0; i < remaining; i++) {
        NSData *imageData = images[i];
        
        if (imageData && [imageData isKindOfClass:[NSData class]]) {
            // has images
            NSLog(@"has image to upload -> upload them then continue");
            
            NSString *url = [NSString stringWithFormat:@"%@/%@/upload", envConfig[@"API_BASE_URI"], envConfig[@"API_CURRENT_VERSION"]];
            NSLog(@"POST /images url: %@", url);
            
            [[Session sharedInstance] authenticate:^(BOOL success, NSString *token) {
                if (success) {
                    AFHTTPSessionManager *localManager = [AFHTTPSessionManager manager];
                    [localManager.requestSerializer setValue:[NSString stringWithFormat:@"Bearer %@", token] forHTTPHeaderField:@"Authorization"];
                    [localManager.requestSerializer setValue:[NSString stringWithFormat:@"iosClient/%@", [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"]] forHTTPHeaderField:@"x-rooms-client"];
                    // [localManager.requestSerializer setValue:@"https://hallway.app" forHTTPHeaderField:@"origin"];
                    // [localManager.requestSerializer setValue:nil forHTTPHeaderField:@"Origin"];
                    
                    [localManager POST:url parameters:nil constructingBodyWithBlock:^(id<AFMultipartFormData>  _Nonnull formData) {
                        NSString *mimeType = [self mimeTypeForData:imageData];
                        if ([mimeType isEqualToString:@"image/jpeg"]) {
                            [formData appendPartWithFileData:imageData name:@"img" fileName:@"image.jpg" mimeType:mimeType];
                        }
                        else if ([mimeType isEqualToString:@"image/gif"]) {
                            [formData appendPartWithFileData:imageData name:@"img" fileName:@"image.gif" mimeType:mimeType];
                        }
                        else if ([mimeType isEqualToString:@"image/png"]) {
                            [formData appendPartWithFileData:imageData name:@"img" fileName:@"image.png" mimeType:mimeType];
                        }
                    } progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
                        NSLog(@"--------");
                        NSLog(@"response object:");
                        NSLog(@"%@", responseObject);
                        NSLog(@"--------");
                        
                        if (responseObject[@"data"] && responseObject[@"data"] != [NSNull null] && [responseObject[@"data"] count] > 0) {
                            [uploadedImages addObject:[NSString stringWithFormat:@"%@", responseObject[@"data"][0][@"id"]]];
                        }
                        
                        remaining = remaining - 1;
                        
                        if (remaining == 0) {
                            handler(true, uploadedImages);
                        }
                    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                        NSLog(@"error: %@", error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey]);
                        NSString* ErrorResponse = [[NSString alloc] initWithData:(NSData *)error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] encoding:NSUTF8StringEncoding];
                        NSLog(@"%@",ErrorResponse);
                        NSLog(@"%@", error);
                        NSLog(@"idk: %@", task.response);
                        
                        if (remaining == 0) {
                            handler(true, uploadedImages);
                        }
                    }];
                }
                else {
                    handler(false, nil);
                }
            }];
        }
        else {
            NSLog(@"does not have image");
            if (remaining == 0) {
                handler(true, uploadedImages);
            }
        }
    }
}
- (NSData *)compressAndEncodeToData:(UIImage *)image
{
    //Scale Image to some width (xFinal)
    float ratio = image.size.width/image.size.height;
    float xFinal = image.size.width;
    if (image.size.width > 1125) {
        xFinal = 1125; //Desired max image width
    }
    float yFinal = xFinal/ratio;
    UIImage *scaledImage = [self imageWithImage:image scaledToSize:CGSizeMake(xFinal, yFinal)];
    
    //Compress the image iteratively until either the maximum compression threshold (maxCompression) is reached or the maximum file size requirement is satisfied (maxSize)
    CGFloat compression = 1.0f;
    CGFloat maxCompression = 0.1f;
    float maxSize = 2*1024*1024; //specified in bytes
    
    NSData *imageData = UIImageJPEGRepresentation(scaledImage, compression);
    while ([imageData length] > maxSize && compression > maxCompression) {
        compression -= 0.10;
        imageData = UIImageJPEGRepresentation(scaledImage, compression);
        NSLog(@"Compressed to: %.2f MB with Factor: %.2f",(float)imageData.length/1024.0f/1024.0f, compression);
    }
    NSLog(@"Final Image Size: %.2f MB",(float)imageData.length/1024.0f/1024.0f);
    return imageData;
}
- (NSString *)mimeTypeForData:(NSData *)data {
    uint8_t c;
    [data getBytes:&c length:1];
    
    switch (c) {
        case 0xFF:
            return @"image/jpeg";
            break;
        case 0x89:
            return @"image/png";
            break;
        case 0x47:
            return @"image/gif";
            break;
        case 0x49:
        case 0x4D:
            return @"image/tiff";
            break;
        case 0x25:
            return @"application/pdf";
            break;
        case 0xD0:
            return @"application/vnd";
            break;
        case 0x46:
            return @"text/plain";
            break;
        default:
            return @"application/octet-stream";
    }
    return nil;
}
// Ancillary method to scale an image based on a CGSize
- (UIImage *)imageWithImage:(UIImage*)originalImage scaledToSize:(CGSize)newSize;
{
    @synchronized(self)
    {
        UIGraphicsBeginImageContext(newSize);
        [originalImage drawInRect:CGRectMake(0,0,newSize.width, newSize.height)];
        UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        return newImage;
    }
    return nil;
}

@end
